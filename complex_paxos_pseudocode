ğš™ğš›ğš˜ğšŒğšğšœğšœ Replica(leaders, initial_state) {
    let state = initial_state, slot_in = 1, slot_out = 1;
    let requests = {}, proposals = {}, decisions = {};

    // propose something.
    fn propose() {
        // slot within bounds and there's a request
        while slot_in < slot_out + WINDOW && âˆƒc:c âˆˆ requests {
            // reconfig thing, give that leadership
            /* if let (slot_in âˆ’ WINDOW, (_, _, op)) âˆˆ decisions && isreconfig(op) {
                leaders = op.leaders;
            } */
            // No consensus for this slot yet, propose
            if âˆ„câ€²:(slot_in, câ€²) âˆˆ decisions {
                // move thing to proposals
                requests.remove(c);
                proposals.push((slot_in, c));

                // send to all leaders
                leaders.map(|Î»| send(Î», (propose, slot_in, c)));
            }
            // Increment proposal slot
            slot_in += 1;
        }
    }

    fn perform(Îº:ActualClient?, cid: ClientID?, op: CompleteMystery){
        // If command (aka thing) is consensus or reconfig
        let c = Command::new(Îº, cid, op); // added this line for coolness
        if (âˆƒs: s < slot_out && (s, c) âˆˆ decisions) {
            slot_out += 1;
        }
        else {
            (next, result) = op(state); // Be function or state machine?
            // why atomic??
            ğšŠğšğš˜ğš–ğš’ğšŒ
                state = next; // set state, duh
                slot_out += 1; // Incrementing this in lots of places, strange
            ğšğš—ğš ğšŠğšğš˜ğš–ğš’ğšŒ
            // pulled response out of indeterminate orifice.
            send(Îº, (response, cid, result));
        }
    }

    // listener
    loop {
        match recv() {
            // request came, add it to requests
            ğšŒğšŠğšœğš (request, c: Command):
                requests.push(c);
                break;

            ğšŒğšŠğšœğš (decision, s, c):
                decisions.push((s, c));
                // what is c?

                // Actually do everything? There's a bunch of performs here.
                // We're actually looping over the slot_out, coz increment inside perform
                while âˆƒcâ€²: (slot_out, câ€²) âˆˆ decisions {
                    // proposal to decision or ded.
                    if âˆƒcâ€³: (slot_out, câ€³) âˆˆ proposals {
                        proposals.remove((slot_out, câ€³));
                        if câ€³ â‰  câ€² {
                            // propose again later
                            requests.push(câ€³);
                        }
                    }
                    perform(câ€²);
                }
        }
        propose(); // propose something??
    }
}

// Prepare/Commit requests
enum PhaseReq {
    p1a,
    p2a,
}

// Prepare/Commit responses
enum PhaseRes {
    p1b,
    p2b,
}

ğš™ğš›ğš˜ğšŒğšğšœğšœ Acceptor(){
    // So ballot_num is the accepted proposal number?

    // uninit ballot_num
    let ballot_num: BallotNumber = âŠ¥, accepted = {};

    loop {
        ğšœğš ğš’ğšğšŒğš‘ receive() {
            // prepare/promise
            ğšŒğšŠğšœğš (PhaseReq::p1a, Î»: LeaderID, b: BallotNumber):
                if b > ballot_num {
                    ballot_num = b;
                }
                send(Î», (PhaseRes::p1b, self, ballot_num, accepted));
            
            // commit
            ğšŒğšŠğšœğš (PhaseReq::p2a, Î»: LeaderID, (b: BallotNumber, s: Slot, c: Command)):
                if b == ballot_num {
                    accepted.push((b,s,c));
                }
                send(Î», (PhaseRes::p2b, self, ballot_num));
            
        }
    }
}

ğš™ğš›ğš˜ğšŒğšğšœğšœ Commander(Î»: LeaderID, acceptors, replicas, (b, s, c): (BallotNumber, Slot, Command)){
    let waitfor = acceptors;

    // Send prepare requests
    âˆ€Î± âˆˆ acceptors : send(Î±, (PhaseReq::p2a, self(), (b, s, c)));
    loop {
        ğšœğš ğš’ğšğšŒğš‘ receive(){
            ğšŒğšŠğšœğš (PhaseRes::p2b, Î±: AcceptorID, bâ€²: BallotNumber):
                if bâ€² = b {
                    waitfor.remove(Î±);
                
                    // Majority of acceptors have responded, send commit responses
                    if |waitfor| < |acceptors| / 2 {
                        âˆ€Ï âˆˆ replicas : send(Ï, (decision, s, c));
                        exit();
                    }
                }
                else { 
                    // Higher ballot/proposal number found, preempted
                    send(Î», (preempted, bâ€²));
                    exit();
                }
        }
    }
}

ğš™ğš›ğš˜ğšŒğšğšœğšœ Scout(Î»: LeaderID, acceptors, b: BallotNumber){
    let waitfor = acceptors, pvalues = {};

    âˆ€Î± âˆˆ acceptors: send(Î±, (PhaseReq::p1a, self, b));
    loop {
        ğšœğš ğš’ğšğšŒğš‘ receive() {
            ğšŒğšŠğšœğš (PhaseRes::p1b, Î±: AcceptorID, bâ€²: BallotNumber, r: ProposedValue?):
                ğš’ğš bâ€² = b {
                    pvalues.push(r);
                    waitfor.remove(Î±);

                    // Majority of acceptors have responded, relay back to leader.
                    ğš’ğš |waitfor| < |acceptors| / 2 {
                        send(Î», (adopted, b, pvalues)); // adopted ain't there.
                        exit();
                    }
                }
                ğšğš•ğšœğš {
                    send(Î», (preempted, bâ€²));
                    exit();
                }
        }
    }
}

// Someone pls fill this up, Imma PCP.
ğš™ğš›ğš˜ğšŒğšğšœğšœ Leader(acceptors, replicas)
    let ballot_num = (0, self), active = false, proposals = {};

    spawn(Scout(self, acceptors, ballot_num));
    loop {
        ğšœğš ğš’ğšğšŒğš‘ receive(){
            ğšŒğšŠğšœğš (propose, s, c):
                ğš’ğš âˆ„câ€²: (s,câ€²) âˆˆ proposals{
                    proposals.push((s, c));
                    ğš’ğš active {
                        spawn(Commander(self, acceptors, replicas, (ballot_num, s, c)));
                    }
                }
            ğšŒğšŠğšœğš (adopted, ballot_num, pvals):
                proposals = proposals âŠ² pmax(pvals); // Wtf is this?
                âˆ€(s,c) âˆˆ proposals : spawn(Commander(self, acceptors, replicas, (ballot_num, s, c)));
                active = true;
            ğšŒğšŠğšœğš (preempted, (râ€², Î»â€²)):
                ğš’ğš (râ€²,Î»â€²) > ballot_num {
                    active = false;
                    ballot_num = (râ€² + 1, self);
                    spawn(Scout(self, acceptors, ballot_num));
                }
            ğšğš—ğš ğšŒğšŠğšœğš
        }
    }
ğšğš—ğš ğš™ğš›ğš˜ğšŒğšğšœğšœ